\section{Introduction}
\emph{We are given an array that contains N numbers and would like to determine if there are two numbers whose sum equals a given number K.\\
For example we may be given the sequence 4,1,5,2,6,3 and are asked to find a pair of numbers with a sum of 10. In this example 4 and 6 is a valid result.\\
To solve the portfolio do the following:}
\begin{itemize}

\item \emph{Implement an O\(\left( { N }^{ 2 } \right)\) algorithm for solving the problem.}
\item \emph{Implement an O\(\left( N\log {(N)}  \right) \) algorithm for solving the problem. (Hint: Consider sorting the list.)}
\item \emph{Perform experiments with different values of N (generate the associated random lists yourselves)and plot the time as function of N, to verify the time complexity.}
\end{itemize}\emph{You may use a build in sorting algorithm and assume that it sorts in \( N\log {(N) }  \).}

\section{Use of Algorithms}
\todo[inline]{short introduction}
\subsection{O\(\left( { N }^{ 2 } \right)\) Algorithm}
\todo[inline]{Description af the algorithm}
\todo[inline]{Pseudocode}

\subsection{O\(\left( N\log {(N)}  \right) \) Algorithm}
The problem is solved using a binary search algorithm. A requirement for the binary searching algorithm is that the vector of number has to be sorted, before a binary search algorithm can be applied. \\
The algorithm starts by checking the first value of the vector, and calculates, what value it needs to pair up with to get a sum of \emph{K}.  Using binary search the needed value will be found in the vector, if the value isn't found in the vector, the next value will be checked.  When a pair is found the algorithm \emph{return 1}. \\

The binary search algorithm in use is a build in algorithm which is available from the standard library \emph{algorithm.h}. The binary search algorithm is a bool, which return true or false depending whether or not it finds the value. The algorithm itself takes 3 parameter, a iterator pointing to first element, a iterator pointing to last element, and the value which has to be found. 
\begin{lstlisting}
binary_search(v.begin(), v.end(), find_value)
\end{lstlisting}

\subsubsection{Time Complexity}
The time complexity is for the worst case O\(\left( N\log {(N)}  \right) \), since the worst case implies that the whole array has to be looked through, and using binary search the searching itself taked \( \log {(N)} \) time, thereby fulfilling the criteria of having a time complexity of O\(\left( N\log {(N)}  \right) \).  



\section{Verify the Time Complexity for the Algorithms}
\subsection{O\(\left( { N }^{ 2 } \right)\) Implementation}
Figure \ref{fig:test1} shows an ideal O\(\left( { N }^{ 2 } \right)\) complexity and the data samples is plotted, time as function of elements. If you compare the plots according to the rate of change the curves are exactly alike. 
\begin{figure}[th!]
\centering
\includegraphics[width=1\textwidth]{./graphics/test1.eps}
\caption{Show plots of an ideal O\(\left( { N }^{ 2 } \right)\) complexity and data samples from the used algorithm.}
\label{fig:test1}
\end{figure}
\newpage


\subsection{O\(\left( N\log {N }  \right) \) Implementation}
Figure \ref{fig:test2} shows an ideal O\(\left( N\log {N }  \right) \) complexity and the data samples plotted as time as function of elements. If you compare the plots according to the rate of change the curves they are exactly alike. 
\begin{figure}[th!]
\centering
\includegraphics[width=1\textwidth]{./graphics/test2.eps}
\caption{Show plots of an ideal O\(\left( N\log {N }  \right) \) complexity and data samples from the used algorithm.}
\label{fig:test2}
\end{figure}



O\(\left( { N }^{ 2 } \right)\)

O\(\left( N\log {(N)}  \right) \)

\( \log {(N)} \)
