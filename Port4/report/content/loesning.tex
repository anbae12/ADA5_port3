\section{Introduction}
\emph{We are given an array that contains N numbers and would like to determine if there are two numbers whose sum equals a given number K.\\
For example we may be given the sequence 4,1,5,2,6,3 and are asked to find a pair of numbers with a sum of 10. In this example 4 and 6 is a valid result.\\
To solve the portfolio do the following:}
\begin{itemize}

\item \emph{Implement an O\(\left( { N }^{ 2 } \right)\) algorithm for solving the problem.}
\item \emph{Implement an O\(\left( N\log {(N)}  \right) \) algorithm for solving the problem. (Hint: Consider sorting the list.)}
\item \emph{Perform experiments with different values of N (generate the associated random lists yourselves)and plot the time as function of N, to verify the time complexity.}
\end{itemize}\emph{You may use a build in sorting algorithm and assume that it sorts in \( N\log {(N) }  \).}

\section{Use of Algorithms}
A description of the algorithms is mentioned in Section \ref{sec:algorithm1} and \ref{sec:algorithm2}. 
The complexity of the algorithms is verified in Section \ref{sec:ver}.
The source code of the algorithms used to solve the problem is showed in Appendix \ref{app:matcher}.


\subsection{O\(\left( { N }^{ 2 } \right)\) Algorithm}
\label{sec:algorithm1} 
To solve the problem in O\(\left( { N }^{ 2 } \right)\), the group has implemented two for-loops. Each for-loop will iterate through all elements in the list thereby O\(\left( { N }^{ 2 } \right)\). For each element, it will then iterate through all elements again to determine if the sum of two elements will yield the result.
\begin{lstlisting}
for element1 in list:
   for element2 in list:
        if element1 + elemt2 = sum:
           return true
\end{lstlisting}
If the sum is found, the function will return true.
The match value has been set to two times the max value in the list plus one to make sure its worst case scenario.
To optimize the implementation, the inner for-loop should only run from the outer-loops' position and forward.
\begin{lstlisting}
 for(int i = 0; i < vector.size(); ++i){
     for(int j = i+1; j < vector.size); ++j){
         ....
     }
 }
\end{lstlisting}
This will give a complexity of O\(\left(N\left(  N - k \right)\right)\) where k is the time the inner for-loop runs.

\subsection{O\(\left( N\log {(N)}  \right) \) Algorithm}
\label{sec:algorithm2}
The complexity is solved using a binary search algorithm. A requirement for the binary search algorithm is that the vector of number has to be sorted, before a binary search algorithm can be applied. \\
The algorithm starts by checking the first value of the vector, and calculates, what value it needs to pair up with to get a sum of \emph{K}.  Using binary search the needed value will be found in the vector, if the value isn't found in the vector, the next value will be checked.  When a pair is found the algorithm \emph{return 1}. \\

A implementation of the binary search algorithm is available from the standard library \emph{algorithm.h}. The binary search algorithm is a boolean, which return true or false depending whether or not it finds the value. The algorithm itself takes 3 parameter, a iterator pointing to first element, a iterator pointing to last element, and the value which has to be found. 
\begin{lstlisting}
binary_search(v.begin(), v.end(), find_value)
\end{lstlisting}

\newpage
\section{Verify the Time Complexity for the Algorithms}
\label{sec:ver}
One hundred lists with elements in range of [1000 100000] elements are used for testing the worst case complexity of the algorithms. To get the worst time case the "search number" must not be included as a element, therefore the lists are not random generated. 


\subsection{O\(\left( { N }^{ 2 } \right)\) Implementation}
Figure \ref{fig:test1} shows an ideal O\(\left( { N }^{ 2 } \right)\) complexity and the data samples is plotted, time as function of elements. If you compare the plots according to the rate of change the curves are exactly alike. \\

\begin{figure}[th!]
\centering
\includegraphics[width=1\textwidth]{./graphics/test1.eps}
\caption{Show plots of an ideal O\(\left( { N }^{ 2 } \right)\) complexity and data samples from the used algorithm.}
\label{fig:test1}
\end{figure}

The complexity in worst case is: O\(\left( { N }^{ 2 } \right)\), since array has to be looked through twice for a match. 


\newpage
\subsection{O\(\left( N\log {N }  \right) \) Implementation}
Figure \ref{fig:test2} shows an ideal O\(\left( N\log {N }  \right) \) complexity and the data samples plotted as time as function of elements. If you compare the plots according to the rate of change the curves they are exactly alike. 
\begin{figure}[th!]
\centering
\includegraphics[width=1\textwidth]{./graphics/test2.eps}
\caption{Show plots of an ideal O\(\left( N\log {N }  \right) \) complexity and data samples from the used algorithm.}
\label{fig:test2}
\end{figure}

The complexity is in worst case O\(\left( N\log {(N)}  \right) \), since the worst case implies that the whole array has to be looked through. And using binary search the searching itself has the complexity \( \log {(N)} \). Thereby the algorithm is fulfilling the criteria of having a complexity of O\(\left( N\log {(N)}  \right) \).  


\section{Conclusion}
By using two different algorithms to find matching numbers in the same data structures it is necessary to think about the complexity of the algorithm as illustrated in Figure \ref{fig:test1} and Figure \ref{fig:test1}. A implementation with the worst case complexity O\(\left( N\log {(N)}  \right) \) is appropriate for this giving problem.
